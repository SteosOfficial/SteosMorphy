[![Go Version](https://img.shields.io/badge/Go-1.17+-blue.svg)](https://golang.org) [![License: Apache 2.0](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0) 
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](http://makeapullrequest.com)





## Documentation

**SteosMorphy** — это высокопроизводительный морфологический анализатор и генератор словоформ (лексем) для русского языка, написанный на Go

Поддерживает языки: Python и Golang


*   🚀 **Высокая производительность**: Десятки тысяч слов в секунду (~20 микросекунд на одно слово)
*   📚 **Огромный встроенный словарь**: 120000+ лексем и 5300000+ словоформ полностью проверенных командой Steos
*   🏷️ **Огромное количество тегов**: 198 тегов для проверенных слов
*   🧠 **Полный морфологический разбор**: Определение леммы (нормальная форма слова) и всех грамматических характеристик (теги)
*   🔄 **Генерация словоформ**: Получение всех словоформ по любой форме слова
*   🔮 **Предсказание несловарных слов**: Анализ и генерация форм для слов, отсутствующих в словаре (OOV, Out-Of-Vocabulary)
*   🐍 **Гибридное использование**: Наличие CGo-обертки для интеграции с Python

## Оглавление

*   [Быстрый старт](#1-быстрый-старт)
    *   [Требования](#11-требования)
    *   [Установка](#12-установка)
    *   [Базовое использование](#13-базовое-использование)
*   [Морфологический анализ (Analyze)](#2-морфологический-анализ-analyze)
    *   [Объект Parsed](#21-объект-parsed)
    *   [Разбор неоднозначности](#22-разбор-неоднозначности)
*   [Генерация словоформ (Lexeme)](#3-генерация-словоформ-lexeme)
    *   [Лексемы и Супплетивизм](#31-лексемы-и-супплетивизм)
    *   [Пакетная обработка](#32-пакетная-обработка)
*   [Работа с несловарными словами (OOV)](#4-работа-с-несловарными-словами-oov)
*   [Продвинутые темы](#5-продвинутые-темы)
    *   [Архитектура хранения и память](#51-архитектура-хранения-и-использование-данных)
    *   [Потокобезопасность](#52-потокобезопасность)
*   [Тестирование](#6-тестирование)
*   [Зависимости и окружение](#7-зависимости-и-окружение)
*   [Справочник по граммемам](#8-справочник-по-граммемам)
*   [Использование в Python](#9-использование-в-python)
*   [Как внести вклад](#как-внести-вклад)
*   [Лицензия](#лицензия)


## 1. Быстрый старт

### 1.1. Требования

*   Go 1.17 или выше (для использования в Go)
*   Python 3.10 или выше (для использования в Python)

### 1.2. Установка (Golang)

Установите библиотеку стандартным для Go способом:
```bash
go get github.com/steosofficial/steosmorphy
```

### 1.3. Базовое использование

Вот простой пример, который показывает основной функционал
```go
package main

import (
	"fmt"
	"github.com/steosofficial/SteosMorphy"
)

func main() {
	// Инициализируем анализатор. Метод LoadMorphAnalyzer() автоматически найдет
	// скомпилированный словарь в папке data/.
	analyzer, err := SteosMorphy.LoadMorphAnalyzer()
	if err != nil {
		panic(err)
	}

	// 1. Анализируем слово
	word := "стали"
	parses, forms := analyzer.Analyze(word)

	// 2. Печатаем варианты разбора
	fmt.Printf("Варианты разбора для слова '%s':\n", word)
	for _, p := range parses {
		fmt.Printf("  - Лемма: %s Часть речи: %s Падеж: %s\n", p.Lemma, p.PartOfSpeech, p.Case)
	}

	// 3. Печатаем несколько словоформ
	fmt.Printf("\nСловоформы для '%s':\n", word)
	for i, p := range forms {
		if i >= 5 { // Ограничим вывод для краткости
			fmt.Println("  ...")
			break
		}
		fmt.Printf("%s\n", p.Word)
	}
}
```

## 2. Морфологический анализ (Analyze)

Основной метод для анализа слова — `analyzer.Analyze(word string)`. Он возвращает два значения:

*   `[]*Parsed`: Срез с вариантами разбора для исходного слова.
*   `[]*Parsed`: Срез со всеми словоформами (лексемой) для этого слова.

Если слово не найдено и не может быть предсказано, оба среза будут `nil`.

### 2.1. Объект `Parsed`

`*Parsed` — это объект, содержащий полный разбор одной словоформы.

*   `Word` (string): Сама словоформа.
*   `Lemma` (string): Нормальная (словарная) форма.
*   `Tags` (string): "Сырая" строка тегов для отладки.
*   `PartOfSpeech` (string): Часть речи.
*   `Animacy` (string): Одушевленность.
*   `Aspect` (string): Вид глагола.
*   `Case` (string): Падеж.
*   `Gender` (string): Род.
*   `Mood` (string): Наклонение.
*   `Number` (string): Число.
*   `Person` (string): Лицо.
*   `Tense` (string): Время.
*   `Transitivity` (string): Переходность.
*   `Voice` (string): Залог.
*   `OtherTags` (GrammemeSet): Множество прочих тегов.

### 2.2. Разбор неоднозначности

Многие слова в русском языке неоднозначны (омонимы). `Analyze` вернет все возможные варианты разбора.

```go
parses, _ := analyzer.Analyze("стали")

// parses будет содержать 2 объекта *Parsed:
// 1. {Lemma: "стать", PartOfSpeech: "Глагол", ...}
// 2. {Lemma: "сталь", PartOfSpeech: "Существительное", Case: "Родительный", ...}

for _, p := range parses {
    if p.PartOfSpeech == "Глагол" {
        // ...
    }
}
```


## 3. Генерация словоформ (Lexeme)

Метод `Analyze` для словарных слов вызывает внутренний метод `Lexeme`, который генерирует полную лексему — совокупность всех словоформ, относящихся к одной лемме.

### 3.1. Лексемы и Супплетивизм

Главная особенность `Lexeme` — корректная обработка супплетивных форм, когда словоформы образуются от разных корней.

```go
// Анализируем слово "хорошая"
_, forms := analyzer.Analyze("хорошая")

// `forms` будет содержать *полную* лексему, включая формы от корня "лучш-":
// - хороший
// - хорошая
// - лучше
// - лучший
// - лучшая
// ... и т.д.
```

Это правильное лингвистическое поведение, позволяющее получить все формы, связанные с одной леммой.

### 3.2. Пакетная обработка

Для обработки больших объемов текста наиболее эффективным способом является использование методов `ParseList` и `InflectList`. Они принимают на вход срез строк и анализируют их в конкурентном режиме, используя пул воркеров, равный количеству ядер CPU.

#### `analyzer.ParseList(words []string) []*Parsed`

*   **Принимает**: Срез строк `[]string`.
*   **Возвращает**: Единый, "плоский" срез `[]*Parsed`, содержащий все возможные разборы для всех слов из входного среза.

#### `analyzer.InflectList(words []string) []*Parsed`

*   **Принимает**: Срез строк `[]string`.
*   **Возвращает**: Единый, "плоский" срез `[]*Parsed`, содержащий все словоформы для каждого слова из входного среза.

```go
texts := []string{"мама", "мыла", "раму", "стали", "программистка", "хороший"}

// Вызываем пакетную обработку
allParses := analyzer.ParseList(texts)

// Результат - один большой срез со всеми разборами
for _, p := range allParses {
    fmt.Printf("Слово: %-15s Лемма: %-15s ЧР: %s\n", p.Word, p.Lemma, p.PartOfSpeech)
}
```

> **Когда использовать `ParseList` / `InflectList`?**
> Всегда, когда вам нужно обработать более тысячи слов за раз. Накладные расходы на создание горутин и каналов амортизируются на больших объемах, и выигрыш в скорости становится значительным.

> **ОСТОРОЖНО**
> Передача на вход метода слишком большого числа слов может потребовать большого объема оперативной памяти. Например, обработка списка из 1 000 000 слов может использовать свыше 2ГБ ОЗУ!

## 4. Работа с несловарными словами (OOV)

Если слово не найдено в словаре, `Analyze` автоматически пытается его предсказать на основе самых длинных совпадающих суффиксов.

```go
// "Нейросеть" - неологизм, его нет в словаре.
parses, forms := analyzer.Analyze("нейросети")

p := parses[0]
// p.Lemma -> "нейросеть"
// p.PartOfSpeech -> "Существительное"
// p.Gender -> "Женский"

// Будут также сгенерированы все предсказанные словоформы:
// "нейросетей", "нейросетью", "нейросетями" и т.д.
```


## 6. Тестирование

Проект поставляется с полным набором автотестов для проверки корректности и производительности.

#### Юнит-тесты

**Как запустить:**
Убедитесь, что вы скомпилировали словарь `data/morph.dawg`. В корневой папке проекта выполните команду:

```bash
# Запустить все тесты
go test ./...

# Запустить тесты с детальным выводом
go test -v ./steosmorphy
```

#### Бенчмарки (Тесты производительности)

**Как запустить:**

```bash
# Запустить все бенчмарки
go test -bench=. ./steosmorphy

# Запустить бенчмарки с информацией о выделении памяти
go test -bench=. -benchmem ./steosmorphy
```


## 9. Использование в Python

`SteosMorphy` можно использовать так же в Python. Для этого установите библиотеку

```bash 
pip install SteosMorphy
```

Далее пользуйтесь готовой библиотекой, например:

```python
# Пример использования в Python
from gomorphy import MorphAnalyzer

# Инициализация экземпляра анализатора
analyzer = MorphAnalyzer()

# API полностью повторяет Go-версию
result = analyzer.analyze("программистка")

# Доступ к полям
p = result.first
print(f"Лемма: {p.lemma}, Падеж: {p.case}")
```

Больше Python примеров смотрите ТУТ (*тут ссылка нужна на Python примеры*)


## Как внести вклад

Мы приветствуем любой вклад в развитие проекта! Если вы нашли ошибку или у вас есть идея по улучшению, пожалуйста, создайте [issue]

## Лицензия

Этот проект распространяется под лицензией Apache 2.0.

Эта лицензия позволяет свободно использовать, изменять и распространять код в коммерческих и некоммерческих целях. Она также предоставляет явное предоставление патентных прав от контрибьюторов пользователям.
Подробности смотрите в файле [LICENSE](LICENSE).
